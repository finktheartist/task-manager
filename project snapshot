ðŸ“¦ GPT Snapshot Version (Copy This Into New Chats)

You can paste the below into any new GPT chat:

Project Snapshot: Python CLI Task Manager (Argparse Version)
Architecture Overview

This is a modular Python CLI task manager using argparse subcommands and JSON persistence.

It uses:

models.py for task creation

storage.py for JSON load/save

todo.py for CLI logic and subcommands

tasks.json for persistent data

The application runs one command per execution (not interactive loop).

Task Data Model

Each task is a dictionary:

{
    "id": int,
    "title": str,
    "completed": bool,
    "priority": "low" | "med" | "high",
    "due_date": "YYYY-MM-DD" | None
}

Core Files
models.py
def create_task(task_id, title):
    return {
        "id": task_id,
        "title": title,
        "completed": False,
        "priority": "med",
        "due_date": None
    }

storage.py
import json

def load_tasks(filename="tasks.json"):
    try:
        with open(filename, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def save_tasks(tasks, filename="tasks.json"):
    with open(filename, "w") as f:
        json.dump(tasks, f, indent=4)

CLI Commands (Argparse Subcommands)

add <title>

list

list --priority

list --todo

list --due

list --overdue

list --today

list --week

complete <id>

uncomplete <id>

delete <id>

setpriority <id> <low|med|high>

setdue <id> <YYYY-MM-DD>

Sorting Logic
Priority ranking
def priority_rank(task):
    order = {"high": 0, "med": 1, "low": 2}
    return order.get(task.get("priority", "med"), 1)

Due date sorting
def due_sort_key(task):
    from datetime import datetime, date

    due = task.get("due_date")
    if not due:
        return date.max

    try:
        return datetime.strptime(due, "%Y-%m-%d").date()
    except ValueError:
        return date.max

Overdue logic
def is_overdue(task):
    from datetime import date

    if task.get("completed"):
        return False

    d = due_sort_key(task)
    return d != date.max and d < date.today()

Command Architecture

Uses argparse with subparsers.

Each command maps to a function:

p = sub.add_parser("complete")
p.add_argument("id", type=int)
p.set_defaults(func=cmd_complete)


Then:

args = parser.parse_args()
args.func(args)


This is a dispatch pattern via argparse.

State of Project

Modular

Production-style CLI architecture

Persistent

Custom sorting

Date handling

Robust validation

Future directions:

Package as installable CLI

Convert to Flask

Add unit tests

Add tagging system

Add recurring tasks